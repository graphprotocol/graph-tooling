/* eslint-disable */
const fs = require('fs');
const path = require('path');

const exportMappingPath = path.join(__dirname, 'package.json');
const exportMapping = JSON.parse(fs.readFileSync(exportMappingPath, 'utf8')).napi['export-mapping'];

const modulesDir = path.join(__dirname, 'mod');

// Ensure the modules directory exists
if (!fs.existsSync(modulesDir)) {
  fs.mkdirSync(modulesDir);
}

const indexDtsPath = path.join(__dirname, 'index.d.ts');
let indexTypeContent = fs.readFileSync(indexDtsPath, 'utf8');

// clean up the extra 'export declare'
indexTypeContent = indexTypeContent.replace(/export declare export declare/g, 'export declare');

const extractDeclarations = (content, functions) => {
  const declarations = [];
  for (const func of functions) {
    const regex = new RegExp(`export declare function ${func}\\(.*`, 'g');
    const matches = content.match(regex);
    if (matches) {
      declarations.push(...matches);
    }
  }
  return declarations;
};

for (const [module, functions] of Object.entries(exportMapping)) {
  const moduleDir = path.join(modulesDir, module);
  if (!fs.existsSync(moduleDir)) {
    fs.mkdirSync(moduleDir);
  }

  const moduleContent = functions
    .map(func => `module.exports.${func} = require('../../index.js').${func};`)
    .join('\n');
  fs.writeFileSync(path.join(moduleDir, 'index.js'), moduleContent, 'utf8');

  const moduleDeclarations = extractDeclarations(indexTypeContent, functions).join('\n');
  const moduleDtsContent = `/* auto-generated by NAPI-RS post-exporter-script */\n/* eslint-disable */\n${moduleDeclarations}\n`;
  fs.writeFileSync(path.join(moduleDir, 'index.d.ts'), moduleDtsContent, 'utf8');
}

// clear the content of the root index.d.ts file
// TODO: instead of completley clearing it up, maybe only remove the declarations for the functions already re-exported under a scoped module, and leave the rest
fs.writeFileSync(indexDtsPath, '', 'utf8');

console.log('Entry points and TypeScript declarations generated successfully.');
